"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RGLM = void 0;
const tslib_1 = require("tslib");
const assert = tslib_1.__importStar(require("assert"));
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
var RGLM;
(function (RGLM) {
    /**
     * RGLM Magic
     */
    RGLM.MAGIC = Buffer.from("RGL\0", "ascii");
    class RGLMChunk {
        chr;
        fg;
        bg;
        st;
        cust;
        static #idcntr = 0;
        /**
         * Formatting mappings, set by parent module
         */
        static mappings = {
            fg: [],
            bg: [],
            st: [],
            cust: [],
        };
        /**
         * Chunk unique id
         */
        _id = RGLMChunk.#idcntr++;
        constructor(chr, fg, bg, st, cust) {
            this.chr = chr;
            this.fg = fg;
            this.bg = bg;
            this.st = st;
            this.cust = cust;
            assert.ok(typeof chr == "string", "Bad Chunk");
            this.chr = chr.replaceAll('\x00', '');
            assert.ok(this.chr.length <= 1 &&
                Buffer.from(this.chr, "ascii").length <= 4 &&
                fg >= 0 && fg <= 0xff &&
                bg >= 0 && bg <= 0xff &&
                st >= 0 && st <= 0xff &&
                cust >= 0 && cust <= 0xff, "Bad Chunk");
        } //ctor
        /**
         * Repack into Buf8
         */
        get pack() {
            const chr = Buffer.alloc(4);
            chr.write(this.chr);
            return Buffer.concat([chr, Buffer.from([this.fg, this.bg, this.st, this.cust])], 8);
        } //g-pack
        /**
         * Craft invalid/blank ender Chunk
         */
        static blank() {
            return new RGLMChunk('', 0xff, 0xff, 0xff, 0xff);
        } //blank
        /**
         * Buf8 -> Chunk
         */
        static parse(buf) {
            return new RGLMChunk(buf.slice(0, 4).toString(), buf[4], buf[5], buf[6], buf[7]);
        } //parse
        /**
         * Chunk string representation
         */
        get print() {
            const fg = RGLMChunk.mappings.fg[this.fg] ?? ((s) => s), bg = RGLMChunk.mappings.bg[this.bg] ?? ((s) => s), st = RGLMChunk.mappings.st[this.st] ?? ((s) => s), cust = RGLMChunk.mappings.cust[this.cust] ?? ((s) => s);
            return cust(st(fg(bg(this.chr.replaceAll('\x00', '')))));
        } //g-print
    } //RGLMChunk
    RGLM.RGLMChunk = RGLMChunk;
    RGLM.blank = RGLMChunk.blank();
    class RGLMap {
        dimens;
        parent;
        scroll;
        static RGLMChunk = RGLMChunk;
        /**
         * Map Chunks
         */
        chunks = [];
        _loadedFrom = "";
        constructor(dimens = [0, 0], parent, scroll = [0, 0]) {
            this.dimens = dimens;
            this.parent = parent;
            this.scroll = scroll;
            assert.ok(dimens instanceof Array && dimens.length == 2 && dimens.every(d => d >= 0) &&
                scroll instanceof Array && scroll.length == 2 && parent, "Bad Map");
            this.dimens = dimens.map(d => Number(d));
            this.scroll = scroll.map(d => Number(d));
        } //ctor
        /**
         * Create empty/blank Map
         */
        static blank(par) {
            return new RGLM.RGLMap([0, 0], par);
        } //blank
        /**
         * Craft Map from fs
         */
        static async parse(from, par) {
            assert.ok(from, "'from' must be provided");
            from = path.resolve(from);
            const dat = await fs.promises.readFile(from, {
                flag: "r"
            }), end = Buffer.from("FFFFFFFF", "hex");
            assert.ok(dat.length >= 8 && !dat.slice(0, 4).compare(Buffer.from("RGL\0", "ascii")), "Broken RGLM");
            let map = new RGLMap([dat.slice(4, 6).readUInt16LE(), dat.slice(6, 8).readUInt16LE()], par), chk, i = 8, passing = true;
            map._loadedFrom = from;
            if (dat.length > 8) {
                do {
                    if (i + 8 > dat.length)
                        throw "Broken RGLM";
                    chk = dat.slice(i, i += 8);
                    if (chk.slice(0, 4).compare(end)) {
                        map.chunks.push(RGLMap.RGLMChunk.parse(chk));
                        if (i == dat.length)
                            break;
                    }
                    else
                        passing = false;
                } while (passing);
            }
            return map;
        } //parse
        /**
         * (Re)store Map to fs
         */
        async store(to = this._loadedFrom) {
            assert.ok(to && typeof to == "string", "'destination' must be a valid path");
            return await fs.promises.writeFile(to, this.pack, {
                encoding: "binary",
                flag: "w",
                mode: 0o775
            });
        } //store
        /**
         * Map -> Buff
         */
        get pack() {
            const dimens = [
                Buffer.allocUnsafe(2),
                Buffer.allocUnsafe(2),
            ];
            dimens[0].writeUInt16LE(this.dimens[0]);
            dimens[1].writeUInt16LE(this.dimens[1]);
            return Buffer.concat([RGLM.MAGIC, ...dimens, ...this.chunks.map(c => c.pack)], (this.chunks.length + 1) * 8);
        } //g-pack
        /**
         * String representation of Map's Chunks
         */
        get print() {
            return this.chunks.map(c => c.print).join('');
        } //g-print
        /**
         * Calculate Viewport coordinates from chunklist index
         */
        calcChkIdx(x, y = 0) {
            if (x instanceof RGLMChunk)
                return this.chunks.findIndex(c => c == x);
            return this.dimens[0] * y + x;
        } //calcChkIdx
        /**
         * Calculate chunklist index from Viewport coordinates
         */
        calcChkCrd(idx) {
            if (idx instanceof RGLMChunk)
                idx = this.chunks.findIndex(c => c == idx);
            return [
                idx % this.dimens[0],
                idx / this.dimens[0]
            ];
        } //calcChkCrd
        /**
         * Get a Chunk
         */
        get(n, x) {
            if (n instanceof RGLMChunk)
                return this.chunks[this.calcChkIdx(n)];
            else if (typeof x == "undefined")
                return this.chunks[n];
            else
                return this.chunks[this.calcChkIdx(n, x)];
        } //get
        /**
         * Place a Chunk
         */
        place(c, n = this.chunks.length, x, repl = 1) {
            const idx = typeof x == "undefined" ? (n instanceof RGLMChunk ? this.calcChkIdx(n) : n) : this.calcChkIdx(n, x);
            return this.chunks.splice(idx, repl, ...c);
        } //place
        /**
         * Check if Chunk is inside bounds
         *
         * t* - chunk target
         * d* - viewport size
         * s* - viewport scroll
         * * - viewport
         */
        isIn(tx, ty, x = 0, y = 0, sx = this.scroll[0], sy = this.scroll[1], dx = this.dimens[0], dy = this.dimens[1]) {
            if (typeof ty == "undefined")
                ([tx, ty] = this.calcChkCrd(tx));
            const rx = tx - sx, ry = ty - sy;
            return rx >= x && rx < dx && ry >= y && ry < dy;
        } //isIn
        /**
         * Imprint Map on RGL
         */
        async stamp(dx = this.dimens[0], dy = this.dimens[1], x = 0, y = 0, sx = this.scroll[0], sy = this.scroll[1], par = this.parent) {
            assert.ok(par, "Bad parent");
            const sav = [...par.cursor];
            for (let idx = 0; idx < this.chunks.length; idx++) {
                const c = this.chunks[idx];
                if (!c.chr)
                    continue;
                if (this.isIn(idx, undefined, x, y, sx, sy, dx, dy)) {
                    await par.move(...this.calcChkCrd(idx));
                    par.write(c.print);
                }
            }
            await par.move(...sav);
            return this;
        } //stamp
    } //RGLMap
    RGLM.RGLMap = RGLMap;
})(RGLM = exports.RGLM || (exports.RGLM = {})); //RGLM
exports.default = RGLM;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUkdMTS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9SR0xNLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7OztBQUViLHVEQUFpQztBQUNqQyxxREFBK0I7QUFDL0IsbURBQTZCO0FBRzdCLElBQWMsSUFBSSxDQStRakI7QUEvUUQsV0FBYyxJQUFJO0lBTWpCOztPQUVHO0lBQ1UsVUFBSyxHQUFtQixNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQVMsQ0FBQztJQU0zRSxNQUFhLFNBQVM7UUF3QkY7UUFBb0I7UUFBbUI7UUFBbUI7UUFBbUI7UUF0QmhHLE1BQU0sQ0FBQyxPQUFPLEdBQVcsQ0FBQyxDQUFDO1FBRTNCOztXQUVHO1FBQ0gsTUFBTSxDQUFDLFFBQVEsR0FLWDtZQUNILEVBQUUsRUFBRSxFQUFFO1lBQ04sRUFBRSxFQUFFLEVBQUU7WUFDTixFQUFFLEVBQUUsRUFBRTtZQUNOLElBQUksRUFBRSxFQUFFO1NBQ1IsQ0FBQztRQUVGOztXQUVHO1FBQ0gsR0FBRyxHQUFXLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUVsQyxZQUFtQixHQUFXLEVBQVMsRUFBVSxFQUFTLEVBQVUsRUFBUyxFQUFVLEVBQVMsSUFBWTtZQUF6RixRQUFHLEdBQUgsR0FBRyxDQUFRO1lBQVMsT0FBRSxHQUFGLEVBQUUsQ0FBUTtZQUFTLE9BQUUsR0FBRixFQUFFLENBQVE7WUFBUyxPQUFFLEdBQUYsRUFBRSxDQUFRO1lBQVMsU0FBSSxHQUFKLElBQUksQ0FBUTtZQUMzRyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sR0FBRyxJQUFJLFFBQVEsRUFBRSxXQUFXLENBQUMsQ0FBQztZQUUvQyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBRXRDLE1BQU0sQ0FBQyxFQUFFLENBQ1IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFN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R0FBRztvQkFBRSxTQUFTO2dCQUVyQixJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFO29CQUNwRCxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7b0JBQ3hDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO2lCQUNuQjthQUNEO1lBRUQsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7WUFFdkIsT0FBTyxJQUFJLENBQUM7UUFDYixDQUFDLENBQUMsT0FBTztNQUVSLFFBQVE7SUE5S0csV0FBTSxTQThLbEIsQ0FBQTtBQUVGLENBQUMsRUEvUWEsSUFBSSxHQUFKLFlBQUksS0FBSixZQUFJLFFBK1FqQixDQUFDLE1BQU07QUFFUixrQkFBZSxJQUFJLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tIFwiYXNzZXJ0XCI7XHJcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmcy1leHRyYVwiO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XHJcbmltcG9ydCByZ2wgZnJvbSBcIi4vcmdsXCI7XHJcblxyXG5leHBvcnQgbW9kdWxlIFJHTE0ge1xyXG5cdFxyXG5cdGV4cG9ydCB0eXBlIEJ1ZjggPSBCdWZmZXIgJiB7IGxlbmd0aDogOCB9O1xyXG5cdGV4cG9ydCB0eXBlIEJ1ZjQgPSBCdWZmZXIgJiB7IGxlbmd0aDogNCB9O1xyXG5cdGV4cG9ydCB0eXBlIEJ1ZjIgPSBCdWZmZXIgJiB7IGxlbmd0aDogMiB9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFJHTE0gTWFnaWNcclxuXHQgKi9cclxuXHRleHBvcnQgY29uc3QgTUFHSUM6IFJlYWRvbmx5PEJ1ZjQ+ID0gQnVmZmVyLmZyb20oXCJSR0xcXDBcIiwgXCJhc2NpaVwiKSBhcyBCdWY0O1xyXG5cdC8qKlxyXG5cdCAqIEJsYW5rL0ludmFsaWQgZW5kZXIgQ2h1bmtcclxuXHQgKi9cclxuXHRleHBvcnQgbGV0IGJsYW5rOiBSZWFkb25seTxSR0xNQ2h1bms+O1xyXG5cdFxyXG5cdGV4cG9ydCBjbGFzcyBSR0xNQ2h1bmsge1xyXG5cdFx0XHJcblx0XHRzdGF0aWMgI2lkY250cjogbnVtYmVyID0gMDtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBGb3JtYXR0aW5nIG1hcHBpbmdzLCBzZXQgYnkgcGFyZW50IG1vZHVsZVxyXG5cdFx0ICovXHJcblx0XHRzdGF0aWMgbWFwcGluZ3M6IHtcclxuXHRcdFx0Zmc6XHRcdCgoczogc3RyaW5nKSA9PiBzdHJpbmcpW107XHJcblx0XHRcdGJnOlx0XHQoKHM6IHN0cmluZykgPT4gc3RyaW5nKVtdO1xyXG5cdFx0XHRzdDpcdFx0KChzOiBzdHJpbmcpID0+IHN0cmluZylbXTtcclxuXHRcdFx0Y3VzdDpcdCgoczogc3RyaW5nKSA9PiBzdHJpbmcpW107XHJcblx0XHR9ID0ge1xyXG5cdFx0XHRmZzogW10sXHJcblx0XHRcdGJnOiBbXSxcclxuXHRcdFx0c3Q6IFtdLFxyXG5cdFx0XHRjdXN0OiBbXSxcclxuXHRcdH07XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQ2h1bmsgdW5pcXVlIGlkXHJcblx0XHQgKi9cclxuXHRcdF9pZDogbnVtYmVyID0gUkdMTUNodW5rLiNpZGNudHIrKztcclxuXHRcdFxyXG5cdFx0Y29uc3RydWN0b3IocHVibGljIGNocjogc3RyaW5nLCBwdWJsaWMgZmc6IG51bWJlciwgcHVibGljIGJnOiBudW1iZXIsIHB1YmxpYyBzdDogbnVtYmVyLCBwdWJsaWMgY3VzdDogbnVtYmVyKSB7XHJcblx0XHRcdGFzc2VydC5vayh0eXBlb2YgY2hyID09IFwic3RyaW5nXCIsIFwiQmFkIENodW5rXCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5jaHIgPSBjaHIucmVwbGFjZUFsbCgnXFx4MDAnLCAnJyk7XHJcblx0XHRcdFxyXG5cdFx0XHRhc3NlcnQub2soXHJcblx0XHRcdFx0dGhpcy5jaHIubGVuZ3RoIDw9IDEgJiZcclxuXHRcdFx0XHRCdWZmZXIuZnJvbSh0aGlzLmNociwgXCJhc2NpaVwiKS5sZW5ndGggPD0gNCAmJlxyXG5cdFx0XHRcdGZnID49IDAgJiYgZmcgPD0gMHhmZiAmJlxyXG5cdFx0XHRcdGJnID49IDAgJiYgYmcgPD0gMHhmZiAmJlxyXG5cdFx0XHRcdHN0ID49IDAgJiYgc3QgPD0gMHhmZiAmJlxyXG5cdFx0XHRcdGN1c3QgPj0gMCAmJiBjdXN0IDw9IDB4ZmYsXHJcblx0XHRcdFwiQmFkIENodW5rXCIpO1xyXG5cdFx0fSAvL2N0b3JcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXBhY2sgaW50byBCdWY4XHJcblx0XHQgKi9cclxuXHRcdGdldCBwYWNrKCk6IEJ1Zjgge1xyXG5cdFx0XHRjb25zdCBjaHI6IEJ1ZjQgPSBCdWZmZXIuYWxsb2MoNCkgYXMgQnVmNDtcclxuXHRcdFx0XHJcblx0XHRcdGNoci53cml0ZSh0aGlzLmNocik7XHJcblx0XHRcdFxyXG5cdFx0XHRyZXR1cm4gQnVmZmVyLmNvbmNhdChbY2hyLCBCdWZmZXIuZnJvbShbdGhpcy5mZywgdGhpcy5iZywgdGhpcy5zdCwgdGhpcy5jdXN0XSldLCA4KSBhcyBCdWY4O1xyXG5cdFx0fSAvL2ctcGFja1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIENyYWZ0IGludmFsaWQvYmxhbmsgZW5kZXIgQ2h1bmtcclxuXHRcdCAqL1xyXG5cdFx0c3RhdGljIGJsYW5rKCk6IFJHTE1DaHVuayB7XHJcblx0XHRcdHJldHVybiBuZXcgUkdMTUNodW5rKCcnLCAweGZmLCAweGZmLCAweGZmLCAweGZmKTtcclxuXHRcdH0gLy9ibGFua1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIEJ1ZjggLT4gQ2h1bmtcclxuXHRcdCAqL1xyXG5cdFx0c3RhdGljIHBhcnNlKGJ1ZjogUmVhZG9ubHk8QnVmOD4pOiBSR0xNQ2h1bmsge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJHTE1DaHVuayhidWYuc2xpY2UoMCwgNCkudG9TdHJpbmcoKSwgYnVmWzRdLCBidWZbNV0sIGJ1Zls2XSwgYnVmWzddKTtcclxuXHRcdH0gLy9wYXJzZVxyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIENodW5rIHN0cmluZyByZXByZXNlbnRhdGlvblxyXG5cdFx0ICovXHJcblx0XHRnZXQgcHJpbnQoKTogc3RyaW5nIHtcclxuXHRcdFx0Y29uc3QgZmc6XHRcdChzOiBzdHJpbmcpID0+IHN0cmluZyA9IFJHTE1DaHVuay5tYXBwaW5ncy5mZ1t0aGlzLmZnXVx0XHQ/PyAoKHM6IHN0cmluZyk6IHN0cmluZyA9PiBzKSxcclxuXHRcdFx0XHRiZzpcdFx0KHM6IHN0cmluZykgPT4gc3RyaW5nID0gUkdMTUNodW5rLm1hcHBpbmdzLmJnW3RoaXMuYmddXHRcdD8/ICgoczogc3RyaW5nKTogc3RyaW5nID0+IHMpLFxyXG5cdFx0XHRcdHN0Olx0XHQoczogc3RyaW5nKSA9PiBzdHJpbmcgPSBSR0xNQ2h1bmsubWFwcGluZ3Muc3RbdGhpcy5zdF1cdFx0Pz8gKChzOiBzdHJpbmcpOiBzdHJpbmcgPT4gcyksXHJcblx0XHRcdFx0Y3VzdDpcdChzOiBzdHJpbmcpID0+IHN0cmluZyA9IFJHTE1DaHVuay5tYXBwaW5ncy5jdXN0W3RoaXMuY3VzdF1cdD8/ICgoczogc3RyaW5nKTogc3RyaW5nID0+IHMpO1xyXG5cdFx0XHRcclxuXHRcdFx0cmV0dXJuIGN1c3Qoc3QoZmcoYmcodGhpcy5jaHIucmVwbGFjZUFsbCgnXFx4MDAnLCAnJykpKSkpO1xyXG5cdFx0fSAvL2ctcHJpbnRcclxuXHRcdFxyXG5cdH0gLy9SR0xNQ2h1bmtcclxuXHRcclxuXHRibGFuayA9IFJHTE1DaHVuay5ibGFuaygpO1xyXG5cclxuXHRleHBvcnQgY2xhc3MgUkdMTWFwIHtcclxuXHRcdHN0YXRpYyBSR0xNQ2h1bms6IHR5cGVvZiBSR0xNQ2h1bmsgPSBSR0xNQ2h1bms7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogTWFwIENodW5rc1xyXG5cdFx0ICovXHJcblx0XHRjaHVua3M6IFJHTE1DaHVua1tdID0gWyBdO1xyXG5cdFx0X2xvYWRlZEZyb206IHN0cmluZyA9IFwiXCI7XHJcblx0XHRcclxuXHRcdGNvbnN0cnVjdG9yKHB1YmxpYyBkaW1lbnM6IFtudW1iZXIsIG51bWJlcl0gPSBbIDAsIDAgXSwgcHVibGljIHBhcmVudDogcmdsLlJHTCwgcHVibGljIHNjcm9sbDogW251bWJlciwgbnVtYmVyXSA9IFsgMCwgMCBdKSB7XHJcblx0XHRcdGFzc2VydC5vayhkaW1lbnMgaW5zdGFuY2VvZiBBcnJheSAmJiBkaW1lbnMubGVuZ3RoID09IDIgJiYgZGltZW5zLmV2ZXJ5KGQgPT4gZCA+PSAwKSAmJlxyXG5cdFx0XHRcdHNjcm9sbCBpbnN0YW5jZW9mIEFycmF5ICYmIHNjcm9sbC5sZW5ndGggPT0gMiAmJiBwYXJlbnQsIFwiQmFkIE1hcFwiKTtcclxuXHRcdFx0XHJcblx0XHRcdHRoaXMuZGltZW5zID0gZGltZW5zLm1hcChkID0+IE51bWJlcihkKSkgYXMgW251bWJlciwgbnVtYmVyXTtcclxuXHRcdFx0dGhpcy5zY3JvbGwgPSBzY3JvbGwubWFwKGQgPT4gTnVtYmVyKGQpKSBhcyBbbnVtYmVyLCBudW1iZXJdO1xyXG5cdFx0fSAvL2N0b3JcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBDcmVhdGUgZW1wdHkvYmxhbmsgTWFwXHJcblx0XHQgKi9cclxuXHRcdHN0YXRpYyBibGFuayhwYXI6IHJnbC5SR0wpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBSR0xNLlJHTE1hcChbIDAsIDAgXSwgcGFyKTtcclxuXHRcdH0gLy9ibGFua1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIENyYWZ0IE1hcCBmcm9tIGZzXHJcblx0XHQgKi9cclxuXHRcdHN0YXRpYyBhc3luYyBwYXJzZShmcm9tOiBzdHJpbmcsIHBhcjogcmdsLlJHTCk6IFByb21pc2U8UkdMTWFwPiB7XHJcblx0XHRcdGFzc2VydC5vayhmcm9tLCBcIidmcm9tJyBtdXN0IGJlIHByb3ZpZGVkXCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0ZnJvbSA9IHBhdGgucmVzb2x2ZShmcm9tKTtcclxuXHRcdFx0Y29uc3QgZGF0OiBCdWZmZXIgPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFkRmlsZShmcm9tLCB7XHJcblx0XHRcdFx0ZmxhZzogXCJyXCJcclxuXHRcdFx0fSksXHJcblx0XHRcdGVuZDogQnVmZmVyID0gQnVmZmVyLmZyb20oXCJGRkZGRkZGRlwiLCBcImhleFwiKTtcclxuXHRcdFx0XHJcblx0XHRcdGFzc2VydC5vayhkYXQubGVuZ3RoID49IDggJiYgIWRhdC5zbGljZSgwLCA0KS5jb21wYXJlKEJ1ZmZlci5mcm9tKFwiUkdMXFwwXCIsIFwiYXNjaWlcIikpLCBcIkJyb2tlbiBSR0xNXCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0bGV0IG1hcCA9IG5ldyBSR0xNYXAoW2RhdC5zbGljZSg0LCA2KS5yZWFkVUludDE2TEUoKSwgZGF0LnNsaWNlKDYsIDgpLnJlYWRVSW50MTZMRSgpXSwgcGFyKSxcclxuXHRcdFx0XHRjaGs6IEJ1ZjgsXHJcblx0XHRcdFx0aTogbnVtYmVyID0gOCxcclxuXHRcdFx0XHRwYXNzaW5nOiBib29sZWFuID0gdHJ1ZTtcclxuXHRcdFx0XHJcblx0XHRcdG1hcC5fbG9hZGVkRnJvbSA9IGZyb207XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoZGF0Lmxlbmd0aCA+IDgpIHtcclxuXHRcdFx0XHRkbyB7XHJcblx0XHRcdFx0XHRpZiAoaSArIDggPiBkYXQubGVuZ3RoKSB0aHJvdyBcIkJyb2tlbiBSR0xNXCI7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdGNoayA9IGRhdC5zbGljZShpLCBpICs9IDgpIGFzIEJ1Zjg7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdGlmIChjaGsuc2xpY2UoMCwgNCkuY29tcGFyZShlbmQpKSB7XHJcblx0XHRcdFx0XHRcdG1hcC5jaHVua3MucHVzaChSR0xNYXAuUkdMTUNodW5rLnBhcnNlKGNoaykpO1xyXG5cdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0aWYgKGkgPT0gZGF0Lmxlbmd0aCkgYnJlYWs7XHJcblx0XHRcdFx0XHR9IGVsc2UgcGFzc2luZyA9IGZhbHNlO1xyXG5cdFx0XHRcdH0gd2hpbGUocGFzc2luZyk7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdHJldHVybiBtYXA7XHJcblx0XHR9IC8vcGFyc2VcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiAoUmUpc3RvcmUgTWFwIHRvIGZzXHJcblx0XHQgKi9cclxuXHRcdGFzeW5jIHN0b3JlKHRvOiBzdHJpbmcgPSB0aGlzLl9sb2FkZWRGcm9tKSB7XHJcblx0XHRcdGFzc2VydC5vayh0byAmJiB0eXBlb2YgdG8gPT0gXCJzdHJpbmdcIiwgXCInZGVzdGluYXRpb24nIG11c3QgYmUgYSB2YWxpZCBwYXRoXCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0cmV0dXJuIGF3YWl0IGZzLnByb21pc2VzLndyaXRlRmlsZSh0bywgdGhpcy5wYWNrLCB7XHJcblx0XHRcdFx0ZW5jb2Rpbmc6IFwiYmluYXJ5XCIsXHJcblx0XHRcdFx0ZmxhZzogXCJ3XCIsXHJcblx0XHRcdFx0bW9kZTogMG83NzVcclxuXHRcdFx0fSk7XHJcblx0XHR9IC8vc3RvcmVcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBNYXAgLT4gQnVmZlxyXG5cdFx0ICovXHJcblx0XHRnZXQgcGFjaygpOiBCdWZmZXIge1xyXG5cdFx0XHRjb25zdCBkaW1lbnM6IFtCdWYyLCBCdWYyXSA9IFtcclxuXHRcdFx0XHRCdWZmZXIuYWxsb2NVbnNhZmUoMikgYXMgQnVmMixcclxuXHRcdFx0XHRCdWZmZXIuYWxsb2NVbnNhZmUoMikgYXMgQnVmMixcclxuXHRcdFx0XTtcclxuXHRcdFx0XHJcblx0XHRcdGRpbWVuc1swXS53cml0ZVVJbnQxNkxFKHRoaXMuZGltZW5zWzBdKTtcclxuXHRcdFx0ZGltZW5zWzFdLndyaXRlVUludDE2TEUodGhpcy5kaW1lbnNbMV0pO1xyXG5cdFx0XHRcclxuXHRcdFx0cmV0dXJuIEJ1ZmZlci5jb25jYXQoW1JHTE0uTUFHSUMsIC4uLmRpbWVucywgLi4udGhpcy5jaHVua3MubWFwKGMgPT4gYy5wYWNrKV0sICh0aGlzLmNodW5rcy5sZW5ndGggKyAxKSAqIDgpO1xyXG5cdFx0fSAvL2ctcGFja1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBNYXAncyBDaHVua3NcclxuXHRcdCAqL1xyXG5cdFx0Z2V0IHByaW50KCk6IHN0cmluZyB7XHJcblx0XHRcdHJldHVybiB0aGlzLmNodW5rcy5tYXAoYyA9PiBjLnByaW50KS5qb2luKCcnKTtcclxuXHRcdH0gLy9nLXByaW50XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQ2FsY3VsYXRlIFZpZXdwb3J0IGNvb3JkaW5hdGVzIGZyb20gY2h1bmtsaXN0IGluZGV4XHJcblx0XHQgKi9cclxuXHRcdGNhbGNDaGtJZHgoeDogbnVtYmVyIHwgUkdMTUNodW5rLCB5OiBudW1iZXIgPSAwKTogbnVtYmVyIHtcclxuXHRcdFx0aWYgKHggaW5zdGFuY2VvZiBSR0xNQ2h1bmspIHJldHVybiB0aGlzLmNodW5rcy5maW5kSW5kZXgoYyA9PiBjID09IHgpO1xyXG5cdFx0XHRcclxuXHRcdFx0cmV0dXJuIHRoaXMuZGltZW5zWzBdICogeSEgKyB4O1xyXG5cdFx0fSAvL2NhbGNDaGtJZHhcclxuXHRcdC8qKlxyXG5cdFx0ICogQ2FsY3VsYXRlIGNodW5rbGlzdCBpbmRleCBmcm9tIFZpZXdwb3J0IGNvb3JkaW5hdGVzXHJcblx0XHQgKi9cclxuXHRcdGNhbGNDaGtDcmQoaWR4OiBudW1iZXIgfCBSR0xNQ2h1bmspOiBbbnVtYmVyLCBudW1iZXJdIHtcclxuXHRcdFx0aWYgKGlkeCBpbnN0YW5jZW9mIFJHTE1DaHVuaykgaWR4ID0gdGhpcy5jaHVua3MuZmluZEluZGV4KGMgPT4gYyA9PSBpZHgpO1xyXG5cdFx0XHRcclxuXHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRpZHggJSB0aGlzLmRpbWVuc1swXSxcclxuXHRcdFx0XHRpZHggLyB0aGlzLmRpbWVuc1swXVxyXG5cdFx0XHRdO1xyXG5cdFx0fSAvL2NhbGNDaGtDcmRcclxuXHRcdC8qKlxyXG5cdFx0ICogR2V0IGEgQ2h1bmtcclxuXHRcdCAqL1xyXG5cdFx0Z2V0KG46IG51bWJlciB8IFJHTE1DaHVuaywgeD86IG51bWJlcik6IFJHTE1DaHVuayB7XHJcblx0XHRcdGlmIChuIGluc3RhbmNlb2YgUkdMTUNodW5rKSByZXR1cm4gdGhpcy5jaHVua3NbdGhpcy5jYWxjQ2hrSWR4KG4pXTtcclxuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIHggPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHRoaXMuY2h1bmtzW25dO1xyXG5cdFx0XHRlbHNlIHJldHVybiB0aGlzLmNodW5rc1t0aGlzLmNhbGNDaGtJZHgobiwgeCldO1xyXG5cdFx0fSAvL2dldFxyXG5cdFx0LyoqXHJcblx0XHQgKiBQbGFjZSBhIENodW5rXHJcblx0XHQgKi9cclxuXHRcdHBsYWNlKGM6IFJHTE1DaHVua1tdLCBuOiBudW1iZXIgfCBSR0xNQ2h1bmsgPSB0aGlzLmNodW5rcy5sZW5ndGgsIHg/OiBudW1iZXIsIHJlcGw6IG51bWJlciA9IDEpIHtcclxuXHRcdFx0Y29uc3QgaWR4OiBudW1iZXIgPSB0eXBlb2YgeCA9PSBcInVuZGVmaW5lZFwiID8gKG4gaW5zdGFuY2VvZiBSR0xNQ2h1bmsgPyB0aGlzLmNhbGNDaGtJZHgobikgOiBuKSA6IHRoaXMuY2FsY0Noa0lkeChuLCB4KTtcclxuXHRcdFx0XHJcblx0XHRcdHJldHVybiB0aGlzLmNodW5rcy5zcGxpY2UoaWR4LCByZXBsLCAuLi5jKTtcclxuXHRcdH0gLy9wbGFjZVxyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIENoZWNrIGlmIENodW5rIGlzIGluc2lkZSBib3VuZHNcclxuXHRcdCAqIFxyXG5cdFx0ICogdCogLSBjaHVuayB0YXJnZXRcclxuXHRcdCAqIGQqIC0gdmlld3BvcnQgc2l6ZVxyXG5cdFx0ICogcyogLSB2aWV3cG9ydCBzY3JvbGxcclxuXHRcdCAqICogLSB2aWV3cG9ydFxyXG5cdFx0ICovXHJcblx0XHRpc0luKHR4OiBudW1iZXIsIHR5PzogbnVtYmVyLCB4OiBudW1iZXIgPSAwLCB5OiBudW1iZXIgPSAwLCBzeDogbnVtYmVyID0gdGhpcy5zY3JvbGxbMF0sIHN5OiBudW1iZXIgPSB0aGlzLnNjcm9sbFsxXSwgZHg6IG51bWJlciA9IHRoaXMuZGltZW5zWzBdLCBkeTogbnVtYmVyID0gdGhpcy5kaW1lbnNbMV0pOiBib29sZWFuIHtcclxuXHRcdFx0aWYgKHR5cGVvZiB0eSA9PSBcInVuZGVmaW5lZFwiKSAoW3R4LCB0eV0gPSB0aGlzLmNhbGNDaGtDcmQodHgpKTtcclxuXHRcdFx0XHJcblx0XHRcdGNvbnN0IHJ4OiBudW1iZXIgPSB0eCAtIHN4LFxyXG5cdFx0XHRcdHJ5OiBudW1iZXIgPSB0eSAtIHN5O1xyXG5cdFx0XHRcclxuXHRcdFx0cmV0dXJuIHJ4ID49IHggJiYgcnggPCBkeCAmJiByeSA+PSB5ICYmIHJ5IDwgZHk7XHJcblx0XHR9IC8vaXNJblxyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIEltcHJpbnQgTWFwIG9uIFJHTFxyXG5cdFx0ICovXHJcblx0XHRhc3luYyBzdGFtcChkeDogbnVtYmVyID0gdGhpcy5kaW1lbnNbMF0sIGR5OiBudW1iZXIgPSB0aGlzLmRpbWVuc1sxXSwgeDogbnVtYmVyID0gMCwgeTogbnVtYmVyID0gMCwgc3g6IG51bWJlciA9IHRoaXMuc2Nyb2xsWzBdLCBzeTogbnVtYmVyID0gdGhpcy5zY3JvbGxbMV0sIHBhcjogcmdsLlJHTCA9IHRoaXMucGFyZW50KTogUHJvbWlzZTx0aGlzPiB7XHJcblx0XHRcdGFzc2VydC5vayhwYXIsIFwiQmFkIHBhcmVudFwiKTtcclxuXHRcdFx0XHJcblx0XHRcdGNvbnN0IHNhdjogW251bWJlciwgbnVtYmVyXSA9IFsuLi5wYXIuY3Vyc29yXTtcclxuXHRcdFx0XHJcblx0XHRcdGZvciAobGV0IGlkeDogbnVtYmVyID0gMDsgaWR4IDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpZHgrKykge1xyXG5cdFx0XHRcdGNvbnN0IGM6IFJHTE0uUkdMTUNodW5rID0gdGhpcy5jaHVua3NbaWR4XTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRpZiAoIWMuY2hyKSBjb250aW51ZTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRpZiAodGhpcy5pc0luKGlkeCwgdW5kZWZpbmVkLCB4LCB5LCBzeCwgc3ksIGR4LCBkeSkpIHtcclxuXHRcdFx0XHRcdGF3YWl0IHBhci5tb3ZlKC4uLnRoaXMuY2FsY0Noa0NyZChpZHgpKTtcclxuXHRcdFx0XHRcdHBhci53cml0ZShjLnByaW50KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGF3YWl0IHBhci5tb3ZlKC4uLnNhdik7XHJcblx0XHRcdFxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0gLy9zdGFtcFxyXG5cdFx0XHJcblx0fSAvL1JHTE1hcFxyXG5cdFxyXG59IC8vUkdMTVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUkdMTTtcclxuIl19