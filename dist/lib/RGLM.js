"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RGLM = void 0;
const tslib_1 = require("tslib");
const assert = tslib_1.__importStar(require("assert"));
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
var RGLM;
(function (RGLM) {
    /**
     * RGLM Magic
     */
    RGLM.MAGIC = Buffer.from("RGL\0", "ascii");
    class RGLMChunk {
        chr;
        fg;
        bg;
        st;
        cust;
        static #idcntr = 0;
        /**
         * Formatting mappings, set by parent module
         */
        static mappings = {
            fg: [],
            bg: [],
            st: [],
            cust: [],
        };
        /**
         * Chunk unique id
         */
        _id = RGLMChunk.#idcntr++;
        onrender = (idx, c, par) => this.print;
        constructor(chr, fg, bg, st, cust) {
            this.chr = chr;
            this.fg = fg;
            this.bg = bg;
            this.st = st;
            this.cust = cust;
            assert.ok(typeof chr == "string", "Bad Chunk");
            this.chr = chr.replaceAll('\x00', '');
            assert.ok(this.chr.length <= 1 &&
                Buffer.from(this.chr, "ascii").length <= 4 &&
                fg >= 0 && fg <= 0xff &&
                bg >= 0 && bg <= 0xff &&
                st >= 0 && st <= 0xff &&
                cust >= 0 && cust <= 0xff, "Bad Chunk");
        } //ctor
        /**
         * Repack into Buf8
         */
        get pack() {
            const chr = Buffer.alloc(4);
            chr.write(this.chr);
            return Buffer.concat([chr, Buffer.from([this.fg, this.bg, this.st, this.cust])], 8);
        } //g-pack
        /**
         * Craft invalid/blank ender Chunk
         */
        static blank() {
            return new RGLMChunk('', 0xff, 0xff, 0xff, 0xff);
        } //blank
        /**
         * Buf8 -> Chunk
         */
        static parse(buf) {
            return new RGLMChunk(buf.slice(0, 4).toString(), buf[4], buf[5], buf[6], buf[7]);
        } //parse
        /**
         * Chunk string representation
         */
        get print() {
            const fg = RGLMChunk.mappings.fg[this.fg] ?? ((s) => s), bg = RGLMChunk.mappings.bg[this.bg] ?? ((s) => s), st = RGLMChunk.mappings.st[this.st] ?? ((s) => s), cust = RGLMChunk.mappings.cust[this.cust] ?? ((s) => s);
            return cust(st(fg(bg(this.chr ?? ' '))));
        } //g-print
    } //RGLMChunk
    RGLM.RGLMChunk = RGLMChunk;
    class RGLMap {
        dimens;
        parent;
        scroll;
        static RGLMChunk = RGLMChunk;
        /**
         * Map Chunks
         */
        chunks = [];
        _loadedFrom = "";
        meta = {};
        constructor(dimens = [0, 0], parent, scroll = [0, 0]) {
            this.dimens = dimens;
            this.parent = parent;
            this.scroll = scroll;
            assert.ok(dimens instanceof Array && dimens.length == 2 && dimens.every(d => d >= 0) &&
                scroll instanceof Array && scroll.length == 2 && parent, "Bad Map");
            this.dimens = dimens.map(d => Number(d));
            this.scroll = scroll.map(d => Number(d));
        } //ctor
        /**
         * Create empty/blank Map
         */
        static blank(par) {
            return new RGLM.RGLMap([0, 0], par);
        } //blank
        /**
         * Craft Map from fs
         */
        static async parse(from, par) {
            assert.ok(from, "'from' must be provided");
            from = path.resolve(from);
            const dat = await fs.promises.readFile(from, {
                flag: "r"
            }), end = Buffer.from("FFFFFFFFFFFFFFFF", "hex");
            assert.ok(dat.length >= 8 && !dat.slice(0, 4).compare(Buffer.from("RGL\0", "ascii")), "Broken RGLM");
            let map = new RGLMap([dat.slice(4, 6).readUInt16LE(), dat.slice(6, 8).readUInt16LE()], par), chk = null, i = 8, passing = true;
            map._loadedFrom = from;
            if (dat.length > 8) {
                do {
                    if (i + 8 > dat.length)
                        throw "Broken RGLM";
                    chk = dat.slice(i, i += 8);
                    if (chk.compare(end)) {
                        map.chunks.push(RGLMap.RGLMChunk.parse(chk));
                        if (i == dat.length)
                            break;
                    }
                    else
                        passing = false;
                } while (passing);
            }
            if (chk && !chk.compare(end)) {
                const meta = dat.slice(i).toString("utf8").split('&');
                for (const met of meta) {
                    const pair = met.split('=');
                    map.meta[pair[0]] = pair[1] ?? '';
                }
            }
            return map;
        } //parse
        /**
         * (Re)store Map to fs
         */
        async store(to = this._loadedFrom) {
            assert.ok(to && typeof to == "string", "'destination' must be a valid path");
            return await fs.promises.writeFile(to, this.pack, {
                encoding: "binary",
                flag: "w",
                mode: 0o775
            });
        } //store
        /**
         * Map -> Buff
         */
        get pack() {
            const dimens = [
                Buffer.allocUnsafe(2),
                Buffer.allocUnsafe(2),
            ];
            let meta = Buffer.from(Object.entries(this.meta).map(e => e.join('=')).join('&'), "utf8");
            dimens[0].writeUInt16LE(this.dimens[0]);
            dimens[1].writeUInt16LE(this.dimens[1]);
            if (meta.length)
                meta = Buffer.concat([Buffer.from("FFFFFFFFFFFFFFFF", "hex"), meta]);
            return Buffer.concat([RGLM.MAGIC, ...dimens, ...this.chunks.map(c => c.pack), meta], (this.chunks.length + 1) * 8 + meta.length);
        } //g-pack
        /**
         * String representation of Map's Chunks
         */
        get print() {
            return this.chunks.map(c => c.print).join('');
        } //g-print
        /**
         * Calculate Viewport coordinates from chunklist index
         */
        calcChkIdx(x, y = 0) {
            if (x instanceof RGLMChunk)
                return this.chunks.findIndex(c => c == x);
            assert.ok(x >= 0, "Bad idx");
            return this.dimens[0] * y + x;
        } //calcChkIdx
        /**
         * Calculate chunklist index from Viewport coordinates
         */
        calcChkCrd(idx) {
            if (idx instanceof RGLMChunk)
                idx = this.chunks.findIndex(c => c == idx);
            assert.ok(idx >= 0, "Bad idx");
            return [
                idx % this.dimens[0],
                Math.floor(idx / this.dimens[0])
            ];
        } //calcChkCrd
        /**
         * Get a Chunk
         */
        get(n, x) {
            if (n instanceof RGLMChunk)
                return this.chunks[this.calcChkIdx(n)];
            else if (typeof x == "undefined")
                return this.chunks[n];
            else
                return this.chunks[this.calcChkIdx(n, x)];
        } //get
        /**
         * Place a Chunk
         */
        place(c, n = this.chunks.length, x, repl = 1) {
            const idx = typeof x == "undefined" ? (n instanceof RGLMChunk ? this.calcChkIdx(n) : n) : this.calcChkIdx(n, x);
            assert.ok(idx >= 0, "Bad idx");
            return this.chunks.splice(idx, repl, ...c);
        } //place
        /**
         * Swap Chunks locations
         */
        swap(c1, c2) {
            const ci1 = this.calcChkIdx(c1);
            assert.ok(ci1 >= 0, "Bad idx");
            const cc1 = this.chunks.splice(ci1, 1)[0];
            const ci2 = this.calcChkIdx(c2);
            assert.ok(ci2 >= 0, "Bad idx");
            const cc2 = this.chunks.splice(ci2, 1, cc1)[0];
            this.chunks.splice(ci1, 0, cc2);
            return this;
        } //swap
        /**
         * Check if Chunk is inside bounds
         *
         * t* - chunk target
         * d* - viewport size
         * s* - viewport scroll
         * * - viewport
         */
        isIn(tx, ty, x = 0, y = 0, sx = this.scroll[0], sy = this.scroll[1], dx = this.dimens[0], dy = this.dimens[1]) {
            if (typeof ty == "undefined")
                ([tx, ty] = this.calcChkCrd(tx));
            const rx = tx - sx, ry = ty - sy;
            return rx >= x && rx < dx && ry >= y && ry < dy;
        } //isIn
        /**
         * Imprint Map on RGL
         */
        async stamp(dx = this.dimens[0], dy = this.dimens[1], x = 0, y = 0, sx = this.scroll[0], sy = this.scroll[1], par = this.parent) {
            assert.ok(par, "Bad parent");
            const sav = [...par.cursor];
            for (let idx = 0; idx < this.chunks.length; idx++) {
                const c = this.chunks[idx];
                if (this.isIn(idx, undefined, x, y, sx, sy, dx, dy)) {
                    await par.move(...(this.calcChkCrd(idx).map((c, idx) => c + [sx, sy][idx])));
                    par.write(c.onrender(idx, c, this));
                }
            }
            await par.move(...sav);
            return this;
        } //stamp
        *[Symbol.iterator]() {
            for (const c of this.chunks)
                yield c;
        }
        get [Symbol.isConcatSpreadable]() {
            return true;
        }
        get [Symbol.toStringTag]() {
            return this.toString();
        }
        toString() {
            return this.print;
        } //toString
    } //RGLMap
    RGLM.RGLMap = RGLMap;
})(RGLM = exports.RGLM || (exports.RGLM = {})); //RGLM
exports.default = RGLM;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUkdMTS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9SR0xNLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7OztBQUViLHVEQUFpQztBQUNqQyxxREFBK0I7QUFDL0IsbURBQTZCO0FBRzdCLElBQWMsSUFBSSxDQThUakI7QUE5VEQsV0FBYyxJQUFJO0lBTWpCOztPQUVHO0lBQ1UsVUFBSyxHQUFtQixNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQVMsQ0FBQztJQUUzRSxNQUFhLFNBQVM7UUF5QkY7UUFBb0I7UUFBbUI7UUFBbUI7UUFBbUI7UUF2QmhHLE1BQU0sQ0FBQyxPQUFPLEdBQVcsQ0FBQyxDQUFDO1FBRTNCOztXQUVHO1FBQ0gsTUFBTSxDQUFDLFFBQVEsR0FLWDtZQUNILEVBQUUsRUFBRSxFQUFFO1lBQ04sRUFBRSxFQUFFLEVBQUU7WUFDTixFQUFFLEVBQUUsRUFBRTtZQUNOLElBQUksRUFBRSxFQUFFO1NBQ1IsQ0FBQztRQUVGOztXQUVHO1FBQ0gsR0FBRyxHQUFXLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNsQyxRQUFRLEdBQStCLENBQUMsR0FBVyxFQUFFLENBQU8sRUFBRSxHQUFnQixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBRTlGLFlBQW1CLEdBQVcsRUFBUyxFQUFVLEVBQVMsRUFBVSxFQUFTLEVBQVUsRUFBUyxJQUFZO1lBQXpGLFFBQUcsR0FBSCxHQUFHLENBQVE7WUFBUyxPQUFFLEdBQUYsRUFBRSxDQUFRO1lBQVMsT0FBRSxHQUFGLEVBQUUsQ0FBUTtZQUFTLE9BQUUsR0FBRixFQUFFLENBQVE7WUFBUyxTQUFJLEdBQUosSUFBSSxDQUFRO1lBQzNHLE1BQU0sQ0FBQyxFQUFFLENBQUMsT0FBTyxHQUFHLElBQUksUUFBUSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1lBRS9DLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLFVB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LENBQXFCLENBQUMsQ0FBQztvQkFDekgsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztpQkFDcEM7YUFDRDtZQUVELE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBRXZCLE9BQU8sSUFBSSxDQUFDO1FBQ2IsQ0FBQyxDQUFDLE9BQU87UUFFVCxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztZQUNqQixLQUFLLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNO2dCQUMxQixNQUFNLENBQUMsQ0FBQztRQUNWLENBQUM7UUFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLGtCQUFrQixDQUFDO1lBQzlCLE9BQU8sSUFBSSxDQUFDO1FBQ2IsQ0FBQztRQUVELElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDO1lBQ3ZCLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3hCLENBQUM7UUFDRCxRQUFRO1lBQ1AsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ25CLENBQUMsQ0FBQyxVQUFVO01BRVgsUUFBUTtJQWxPRyxXQUFNLFNBa09sQixDQUFBO0FBRUYsQ0FBQyxFQTlUYSxJQUFJLEdBQUosWUFBSSxLQUFKLFlBQUksUUE4VGpCLENBQUMsTUFBTTtBQUVSLGtCQUFlLElBQUksQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0ICogYXMgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcclxuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzLWV4dHJhXCI7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcclxuaW1wb3J0ICogYXMgcmdsIGZyb20gXCIuL3JnbFwiO1xyXG5cclxuZXhwb3J0IG1vZHVsZSBSR0xNIHtcclxuXHRcclxuXHRleHBvcnQgdHlwZSBCdWY4ID0gQnVmZmVyICYgeyBsZW5ndGg6IDggfTtcclxuXHRleHBvcnQgdHlwZSBCdWY0ID0gQnVmZmVyICYgeyBsZW5ndGg6IDQgfTtcclxuXHRleHBvcnQgdHlwZSBCdWYyID0gQnVmZmVyICYgeyBsZW5ndGg6IDIgfTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBSR0xNIE1hZ2ljXHJcblx0ICovXHJcblx0ZXhwb3J0IGNvbnN0IE1BR0lDOiBSZWFkb25seTxCdWY0PiA9IEJ1ZmZlci5mcm9tKFwiUkdMXFwwXCIsIFwiYXNjaWlcIikgYXMgQnVmNDtcclxuXHRcclxuXHRleHBvcnQgY2xhc3MgUkdMTUNodW5rIHtcclxuXHRcdFxyXG5cdFx0c3RhdGljICNpZGNudHI6IG51bWJlciA9IDA7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogRm9ybWF0dGluZyBtYXBwaW5ncywgc2V0IGJ5IHBhcmVudCBtb2R1bGVcclxuXHRcdCAqL1xyXG5cdFx0c3RhdGljIG1hcHBpbmdzOiB7XHJcblx0XHRcdGZnOlx0XHQoKHM6IHN0cmluZykgPT4gc3RyaW5nKVtdO1xyXG5cdFx0XHRiZzpcdFx0KChzOiBzdHJpbmcpID0+IHN0cmluZylbXTtcclxuXHRcdFx0c3Q6XHRcdCgoczogc3RyaW5nKSA9PiBzdHJpbmcpW107XHJcblx0XHRcdGN1c3Q6XHQoKHM6IHN0cmluZykgPT4gc3RyaW5nKVtdO1xyXG5cdFx0fSA9IHtcclxuXHRcdFx0Zmc6IFtdLFxyXG5cdFx0XHRiZzogW10sXHJcblx0XHRcdHN0OiBbXSxcclxuXHRcdFx0Y3VzdDogW10sXHJcblx0XHR9O1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIENodW5rIHVuaXF1ZSBpZFxyXG5cdFx0ICovXHJcblx0XHRfaWQ6IG51bWJlciA9IFJHTE1DaHVuay4jaWRjbnRyKys7XHJcblx0XHRvbnJlbmRlcjogKC4uLmRhdGE6IGFueVtdKSA9PiBzdHJpbmcgPSAoaWR4OiBudW1iZXIsIGM6IHRoaXMsIHBhcjogUkdMTS5SR0xNYXApID0+IHRoaXMucHJpbnQ7XHJcblx0XHRcclxuXHRcdGNvbnN0cnVjdG9yKHB1YmxpYyBjaHI6IHN0cmluZywgcHVibGljIGZnOiBudW1iZXIsIHB1YmxpYyBiZzogbnVtYmVyLCBwdWJsaWMgc3Q6IG51bWJlciwgcHVibGljIGN1c3Q6IG51bWJlcikge1xyXG5cdFx0XHRhc3NlcnQub2sodHlwZW9mIGNociA9PSBcInN0cmluZ1wiLCBcIkJhZCBDaHVua1wiKTtcclxuXHRcdFx0XHJcblx0XHRcdHRoaXMuY2hyID0gY2hyLnJlcGxhY2VBbGwoJ1xceDAwJywgJycpO1xyXG5cdFx0XHRcclxuXHRcdFx0YXNzZXJ0Lm9rKFxyXG5cdFx0XHRcdHRoaXMuY2hyLmxlbmd0aCA8PSAxICYmXHJcblx0XHRcdFx0QnVmZmVyLmZyb20odGhpcy5jaHIsIFwiYXNjaWlcIikubGVuZ3RoIDw9IDQgJiZcclxuXHRcdFx0XHRmZyA+PSAwICYmIGZnIDw9IDB4ZmYgJiZcclxuXHRcdFx0XHRiZyA+PSAwICYmIGJnIDw9IDB4ZmYgJiZcclxuXHRcdFx0XHRzdCA+PSAwICYmIHN0IDw9IDB4ZmYgJiZcclxuXHRcdFx0XHRjdXN0ID49IDAgJiYgY3VzdCA8PSAweGZmLFxyXG5cdFx0XHRcIkJhZCBDaHVua1wiKTtcclxuXHRcdH0gLy9jdG9yXHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogUmVwYWNrIGludG8gQnVmOFxyXG5cdFx0ICovXHJcblx0XHRnZXQgcGFjaygpOiBCdWY4IHtcclxuXHRcdFx0Y29uc3QgY2hyOiBCdWY0ID0gQnVmZmVyLmFsbG9jKDQpIGFzIEJ1ZjQ7XHJcblx0XHRcdFxyXG5cdFx0XHRjaHIud3JpdGUodGhpcy5jaHIpO1xyXG5cdFx0XHRcclxuXHRcdFx0cmV0dXJuIEJ1ZmZlci5jb25jYXQoW2NociwgQnVmZmVyLmZyb20oW3RoaXMuZmcsIHRoaXMuYmcsIHRoaXMuc3QsIHRoaXMuY3VzdF0pXSwgOCkgYXMgQnVmODtcclxuXHRcdH0gLy9nLXBhY2tcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBDcmFmdCBpbnZhbGlkL2JsYW5rIGVuZGVyIENodW5rXHJcblx0XHQgKi9cclxuXHRcdHN0YXRpYyBibGFuaygpOiBSR0xNQ2h1bmsge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJHTE1DaHVuaygnJywgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZik7XHJcblx0XHR9IC8vYmxhbmtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBCdWY4IC0+IENodW5rXHJcblx0XHQgKi9cclxuXHRcdHN0YXRpYyBwYXJzZShidWY6IFJlYWRvbmx5PEJ1Zjg+KTogUkdMTUNodW5rIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBSR0xNQ2h1bmsoYnVmLnNsaWNlKDAsIDQpLnRvU3RyaW5nKCksIGJ1Zls0XSwgYnVmWzVdLCBidWZbNl0sIGJ1Zls3XSk7XHJcblx0XHR9IC8vcGFyc2VcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBDaHVuayBzdHJpbmcgcmVwcmVzZW50YXRpb25cclxuXHRcdCAqL1xyXG5cdFx0Z2V0IHByaW50KCk6IHN0cmluZyB7XHJcblx0XHRcdGNvbnN0IGZnOlx0KHM6IHN0cmluZykgPT4gc3RyaW5nID0gUkdMTUNodW5rLm1hcHBpbmdzLmZnW3RoaXMuZmddXHRcdD8/ICgoczogc3RyaW5nKTogc3RyaW5nID0+IHMpLFxyXG5cdFx0XHRcdGJnOlx0XHQoczogc3RyaW5nKSA9PiBzdHJpbmcgPSBSR0xNQ2h1bmsubWFwcGluZ3MuYmdbdGhpcy5iZ11cdFx0Pz8gKChzOiBzdHJpbmcpOiBzdHJpbmcgPT4gcyksXHJcblx0XHRcdFx0c3Q6XHRcdChzOiBzdHJpbmcpID0+IHN0cmluZyA9IFJHTE1DaHVuay5tYXBwaW5ncy5zdFt0aGlzLnN0XVx0XHQ/PyAoKHM6IHN0cmluZyk6IHN0cmluZyA9PiBzKSxcclxuXHRcdFx0XHRjdXN0Olx0KHM6IHN0cmluZykgPT4gc3RyaW5nID0gUkdMTUNodW5rLm1hcHBpbmdzLmN1c3RbdGhpcy5jdXN0XVx0Pz8gKChzOiBzdHJpbmcpOiBzdHJpbmcgPT4gcyk7XHJcblx0XHRcdFxyXG5cdFx0XHRyZXR1cm4gY3VzdChzdChmZyhiZyh0aGlzLmNociA/PyAnICcpKSkpO1xyXG5cdFx0fSAvL2ctcHJpbnRcclxuXHRcdFxyXG5cdH0gLy9SR0xNQ2h1bmtcclxuXHJcblx0ZXhwb3J0IGNsYXNzIFJHTE1hcCB7XHJcblx0XHRzdGF0aWMgUkdMTUNodW5rOiB0eXBlb2YgUkdMTUNodW5rID0gUkdMTUNodW5rO1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIE1hcCBDaHVua3NcclxuXHRcdCAqL1xyXG5cdFx0Y2h1bmtzOiBSR0xNQ2h1bmtbXSA9IFsgXTtcclxuXHRcdF9sb2FkZWRGcm9tOiBzdHJpbmcgPSBcIlwiO1xyXG5cdFx0bWV0YToge1xyXG5cdFx0XHRba2V5OiBzdHJpbmddOiBzdHJpbmc7XHJcblx0XHR9ID0geyB9O1xyXG5cdFx0XHJcblx0XHRjb25zdHJ1Y3RvcihwdWJsaWMgZGltZW5zOiBbbnVtYmVyLCBudW1iZXJdID0gWyAwLCAwIF0sIHB1YmxpYyBwYXJlbnQ6IHJnbC5yZ2wuUkdMLCBwdWJsaWMgc2Nyb2xsOiBbbnVtYmVyLCBudW1iZXJdID0gWyAwLCAwIF0pIHtcclxuXHRcdFx0YXNzZXJ0Lm9rKGRpbWVucyBpbnN0YW5jZW9mIEFycmF5ICYmIGRpbWVucy5sZW5ndGggPT0gMiAmJiBkaW1lbnMuZXZlcnkoZCA9PiBkID49IDApICYmXHJcblx0XHRcdFx0c2Nyb2xsIGluc3RhbmNlb2YgQXJyYXkgJiYgc2Nyb2xsLmxlbmd0aCA9PSAyICYmIHBhcmVudCwgXCJCYWQgTWFwXCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5kaW1lbnMgPSBkaW1lbnMubWFwKGQgPT4gTnVtYmVyKGQpKSBhcyBbbnVtYmVyLCBudW1iZXJdO1xyXG5cdFx0XHR0aGlzLnNjcm9sbCA9IHNjcm9sbC5tYXAoZCA9PiBOdW1iZXIoZCkpIGFzIFtudW1iZXIsIG51bWJlcl07XHJcblx0XHR9IC8vY3RvclxyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIENyZWF0ZSBlbXB0eS9ibGFuayBNYXBcclxuXHRcdCAqL1xyXG5cdFx0c3RhdGljIGJsYW5rKHBhcjogcmdsLnJnbC5SR0wpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBSR0xNLlJHTE1hcChbIDAsIDAgXSwgcGFyKTtcclxuXHRcdH0gLy9ibGFua1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIENyYWZ0IE1hcCBmcm9tIGZzXHJcblx0XHQgKi9cclxuXHRcdHN0YXRpYyBhc3luYyBwYXJzZShmcm9tOiBzdHJpbmcsIHBhcjogcmdsLnJnbC5SR0wpOiBQcm9taXNlPFJHTE1hcD4ge1xyXG5cdFx0XHRhc3NlcnQub2soZnJvbSwgXCInZnJvbScgbXVzdCBiZSBwcm92aWRlZFwiKTtcclxuXHRcdFx0XHJcblx0XHRcdGZyb20gPSBwYXRoLnJlc29sdmUoZnJvbSk7XHJcblx0XHRcdGNvbnN0IGRhdDogQnVmZmVyID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUoZnJvbSwge1xyXG5cdFx0XHRcdGZsYWc6IFwiclwiXHJcblx0XHRcdH0pLFxyXG5cdFx0XHRlbmQ6IEJ1ZjggPSBCdWZmZXIuZnJvbShcIkZGRkZGRkZGRkZGRkZGRkZcIiwgXCJoZXhcIikgYXMgQnVmODtcclxuXHRcdFx0XHJcblx0XHRcdGFzc2VydC5vayhkYXQubGVuZ3RoID49IDggJiYgIWRhdC5zbGljZSgwLCA0KS5jb21wYXJlKEJ1ZmZlci5mcm9tKFwiUkdMXFwwXCIsIFwiYXNjaWlcIikpLCBcIkJyb2tlbiBSR0xNXCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0bGV0IG1hcCA9IG5ldyBSR0xNYXAoW2RhdC5zbGljZSg0LCA2KS5yZWFkVUludDE2TEUoKSwgZGF0LnNsaWNlKDYsIDgpLnJlYWRVSW50MTZMRSgpXSwgcGFyKSxcclxuXHRcdFx0XHRjaGs6IHJnbC5OdWxsYWJsZTxCdWY4PiA9IG51bGwsXHJcblx0XHRcdFx0aTogbnVtYmVyID0gOCxcclxuXHRcdFx0XHRwYXNzaW5nOiBib29sZWFuID0gdHJ1ZTtcclxuXHRcdFx0XHJcblx0XHRcdG1hcC5fbG9hZGVkRnJvbSA9IGZyb207XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoZGF0Lmxlbmd0aCA+IDgpIHtcclxuXHRcdFx0XHRkbyB7XHJcblx0XHRcdFx0XHRpZiAoaSArIDggPiBkYXQubGVuZ3RoKSB0aHJvdyBcIkJyb2tlbiBSR0xNXCI7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdGNoayA9IGRhdC5zbGljZShpLCBpICs9IDgpIGFzIEJ1Zjg7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdGlmIChjaGsuY29tcGFyZShlbmQpKSB7XHJcblx0XHRcdFx0XHRcdG1hcC5jaHVua3MucHVzaChSR0xNYXAuUkdMTUNodW5rLnBhcnNlKGNoaykpO1xyXG5cdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0aWYgKGkgPT0gZGF0Lmxlbmd0aCkgYnJlYWs7XHJcblx0XHRcdFx0XHR9IGVsc2UgcGFzc2luZyA9IGZhbHNlO1xyXG5cdFx0XHRcdH0gd2hpbGUocGFzc2luZyk7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGlmIChjaGsgJiYgIWNoay5jb21wYXJlKGVuZCkpIHtcclxuXHRcdFx0XHRjb25zdCBtZXRhOiBzdHJpbmdbXSA9IGRhdC5zbGljZShpKS50b1N0cmluZyhcInV0ZjhcIikuc3BsaXQoJyYnKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRmb3IgKGNvbnN0IG1ldCBvZiBtZXRhKSB7XHJcblx0XHRcdFx0XHRjb25zdCBwYWlyOiBbc3RyaW5nLCBzdHJpbmddIHwgW3N0cmluZ10gPSBtZXQuc3BsaXQoJz0nKSBhcyBbc3RyaW5nLCBzdHJpbmddIHwgW3N0cmluZ107XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdG1hcC5tZXRhW3BhaXJbMF1dID0gcGFpclsxXSA/PyAnJztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdHJldHVybiBtYXA7XHJcblx0XHR9IC8vcGFyc2VcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiAoUmUpc3RvcmUgTWFwIHRvIGZzXHJcblx0XHQgKi9cclxuXHRcdGFzeW5jIHN0b3JlKHRvOiBzdHJpbmcgPSB0aGlzLl9sb2FkZWRGcm9tKSB7XHJcblx0XHRcdGFzc2VydC5vayh0byAmJiB0eXBlb2YgdG8gPT0gXCJzdHJpbmdcIiwgXCInZGVzdGluYXRpb24nIG11c3QgYmUgYSB2YWxpZCBwYXRoXCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0cmV0dXJuIGF3YWl0IGZzLnByb21pc2VzLndyaXRlRmlsZSh0bywgdGhpcy5wYWNrLCB7XHJcblx0XHRcdFx0ZW5jb2Rpbmc6IFwiYmluYXJ5XCIsXHJcblx0XHRcdFx0ZmxhZzogXCJ3XCIsXHJcblx0XHRcdFx0bW9kZTogMG83NzVcclxuXHRcdFx0fSk7XHJcblx0XHR9IC8vc3RvcmVcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBNYXAgLT4gQnVmZlxyXG5cdFx0ICovXHJcblx0XHRnZXQgcGFjaygpOiBCdWZmZXIge1xyXG5cdFx0XHRjb25zdCBkaW1lbnM6IFtCdWYyLCBCdWYyXSA9IFtcclxuXHRcdFx0XHRCdWZmZXIuYWxsb2NVbnNhZmUoMikgYXMgQnVmMixcclxuXHRcdFx0XHRCdWZmZXIuYWxsb2NVbnNhZmUoMikgYXMgQnVmMixcclxuXHRcdFx0XTtcclxuXHRcdFx0bGV0IG1ldGE6IEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKE9iamVjdC5lbnRyaWVzKHRoaXMubWV0YSkubWFwKGUgPT4gZS5qb2luKCc9JykpLmpvaW4oJyYnKSwgXCJ1dGY4XCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0ZGltZW5zWzBdLndyaXRlVUludDE2TEUodGhpcy5kaW1lbnNbMF0pO1xyXG5cdFx0XHRkaW1lbnNbMV0ud3JpdGVVSW50MTZMRSh0aGlzLmRpbWVuc1sxXSk7XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAobWV0YS5sZW5ndGgpIG1ldGEgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShcIkZGRkZGRkZGRkZGRkZGRkZcIiwgXCJoZXhcIiksIG1ldGFdKTtcclxuXHRcdFx0XHJcblx0XHRcdHJldHVybiBCdWZmZXIuY29uY2F0KFtSR0xNLk1BR0lDLCAuLi5kaW1lbnMsIC4uLnRoaXMuY2h1bmtzLm1hcChjID0+IGMucGFjayksIG1ldGFdLCAodGhpcy5jaHVua3MubGVuZ3RoICsgMSkgKiA4ICsgbWV0YS5sZW5ndGgpO1xyXG5cdFx0fSAvL2ctcGFja1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBNYXAncyBDaHVua3NcclxuXHRcdCAqL1xyXG5cdFx0Z2V0IHByaW50KCk6IHN0cmluZyB7XHJcblx0XHRcdHJldHVybiB0aGlzLmNodW5rcy5tYXAoYyA9PiBjLnByaW50KS5qb2luKCcnKTtcclxuXHRcdH0gLy9nLXByaW50XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQ2FsY3VsYXRlIFZpZXdwb3J0IGNvb3JkaW5hdGVzIGZyb20gY2h1bmtsaXN0IGluZGV4XHJcblx0XHQgKi9cclxuXHRcdGNhbGNDaGtJZHgoeDogbnVtYmVyIHwgUkdMTUNodW5rLCB5OiBudW1iZXIgPSAwKTogbnVtYmVyIHtcclxuXHRcdFx0aWYgKHggaW5zdGFuY2VvZiBSR0xNQ2h1bmspIHJldHVybiB0aGlzLmNodW5rcy5maW5kSW5kZXgoYyA9PiBjID09IHgpO1xyXG5cdFx0XHRcclxuXHRcdFx0YXNzZXJ0Lm9rKHggPj0gMCwgXCJCYWQgaWR4XCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0cmV0dXJuIHRoaXMuZGltZW5zWzBdICogeSEgKyB4O1xyXG5cdFx0fSAvL2NhbGNDaGtJZHhcclxuXHRcdC8qKlxyXG5cdFx0ICogQ2FsY3VsYXRlIGNodW5rbGlzdCBpbmRleCBmcm9tIFZpZXdwb3J0IGNvb3JkaW5hdGVzXHJcblx0XHQgKi9cclxuXHRcdGNhbGNDaGtDcmQoaWR4OiBudW1iZXIgfCBSR0xNQ2h1bmspOiBbbnVtYmVyLCBudW1iZXJdIHtcclxuXHRcdFx0aWYgKGlkeCBpbnN0YW5jZW9mIFJHTE1DaHVuaykgaWR4ID0gdGhpcy5jaHVua3MuZmluZEluZGV4KGMgPT4gYyA9PSBpZHgpO1xyXG5cdFx0XHRcclxuXHRcdFx0YXNzZXJ0Lm9rKGlkeCA+PSAwLCBcIkJhZCBpZHhcIik7XHJcblx0XHRcdFxyXG5cdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdGlkeCAlIHRoaXMuZGltZW5zWzBdLFxyXG5cdFx0XHRcdE1hdGguZmxvb3IoaWR4IC8gdGhpcy5kaW1lbnNbMF0pXHJcblx0XHRcdF07XHJcblx0XHR9IC8vY2FsY0Noa0NyZFxyXG5cdFx0LyoqXHJcblx0XHQgKiBHZXQgYSBDaHVua1xyXG5cdFx0ICovXHJcblx0XHRnZXQobjogbnVtYmVyIHwgUkdMTUNodW5rLCB4PzogbnVtYmVyKTogUkdMTUNodW5rIHtcclxuXHRcdFx0aWYgKG4gaW5zdGFuY2VvZiBSR0xNQ2h1bmspIHJldHVybiB0aGlzLmNodW5rc1t0aGlzLmNhbGNDaGtJZHgobildO1xyXG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgeCA9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gdGhpcy5jaHVua3Nbbl07XHJcblx0XHRcdGVsc2UgcmV0dXJuIHRoaXMuY2h1bmtzW3RoaXMuY2FsY0Noa0lkeChuLCB4KV07XHJcblx0XHR9IC8vZ2V0XHJcblx0XHQvKipcclxuXHRcdCAqIFBsYWNlIGEgQ2h1bmtcclxuXHRcdCAqL1xyXG5cdFx0cGxhY2UoYzogUkdMTUNodW5rW10sIG46IG51bWJlciB8IFJHTE1DaHVuayA9IHRoaXMuY2h1bmtzLmxlbmd0aCwgeD86IG51bWJlciwgcmVwbDogbnVtYmVyID0gMSkge1xyXG5cdFx0XHRjb25zdCBpZHg6IG51bWJlciA9IHR5cGVvZiB4ID09IFwidW5kZWZpbmVkXCIgPyAobiBpbnN0YW5jZW9mIFJHTE1DaHVuayA/IHRoaXMuY2FsY0Noa0lkeChuKSA6IG4pIDogdGhpcy5jYWxjQ2hrSWR4KG4sIHgpO1xyXG5cdFx0XHRcclxuXHRcdFx0YXNzZXJ0Lm9rKGlkeCA+PSAwLCBcIkJhZCBpZHhcIik7XHJcblx0XHRcdFxyXG5cdFx0XHRyZXR1cm4gdGhpcy5jaHVua3Muc3BsaWNlKGlkeCwgcmVwbCwgLi4uYyk7XHJcblx0XHR9IC8vcGxhY2VcclxuXHRcdC8qKlxyXG5cdFx0ICogU3dhcCBDaHVua3MgbG9jYXRpb25zXHJcblx0XHQgKi9cclxuXHRcdHN3YXAoYzE6IFJHTE1DaHVuaywgYzI6IFJHTE1DaHVuayk6IHRoaXMge1xyXG5cdFx0XHRjb25zdCBjaTE6IG51bWJlciA9IHRoaXMuY2FsY0Noa0lkeChjMSk7XHJcblx0XHRcdGFzc2VydC5vayhjaTEgPj0gMCwgXCJCYWQgaWR4XCIpO1xyXG5cdFx0XHRjb25zdCBjYzE6IFJHTE1DaHVuayA9IHRoaXMuY2h1bmtzLnNwbGljZShjaTEsIDEpWzBdO1xyXG5cdFx0XHRcclxuXHRcdFx0Y29uc3QgY2kyOiBudW1iZXIgPSB0aGlzLmNhbGNDaGtJZHgoYzIpO1xyXG5cdFx0XHRhc3NlcnQub2soY2kyID49IDAsIFwiQmFkIGlkeFwiKTtcclxuXHRcdFx0Y29uc3QgY2MyOiBSR0xNQ2h1bmsgPSB0aGlzLmNodW5rcy5zcGxpY2UoY2kyLCAxLCBjYzEpWzBdO1xyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5jaHVua3Muc3BsaWNlKGNpMSwgMCwgY2MyKTtcclxuXHRcdFx0XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fSAvL3N3YXBcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBDaGVjayBpZiBDaHVuayBpcyBpbnNpZGUgYm91bmRzXHJcblx0XHQgKiBcclxuXHRcdCAqIHQqIC0gY2h1bmsgdGFyZ2V0XHJcblx0XHQgKiBkKiAtIHZpZXdwb3J0IHNpemVcclxuXHRcdCAqIHMqIC0gdmlld3BvcnQgc2Nyb2xsXHJcblx0XHQgKiAqIC0gdmlld3BvcnRcclxuXHRcdCAqL1xyXG5cdFx0aXNJbih0eDogbnVtYmVyLCB0eT86IG51bWJlciwgeDogbnVtYmVyID0gMCwgeTogbnVtYmVyID0gMCwgc3g6IG51bWJlciA9IHRoaXMuc2Nyb2xsWzBdLCBzeTogbnVtYmVyID0gdGhpcy5zY3JvbGxbMV0sIGR4OiBudW1iZXIgPSB0aGlzLmRpbWVuc1swXSwgZHk6IG51bWJlciA9IHRoaXMuZGltZW5zWzFdKTogYm9vbGVhbiB7XHJcblx0XHRcdGlmICh0eXBlb2YgdHkgPT0gXCJ1bmRlZmluZWRcIikgKFt0eCwgdHldID0gdGhpcy5jYWxjQ2hrQ3JkKHR4KSk7XHJcblx0XHRcdFxyXG5cdFx0XHRjb25zdCByeDogbnVtYmVyID0gdHggLSBzeCxcclxuXHRcdFx0XHRyeTogbnVtYmVyID0gdHkgLSBzeTtcclxuXHRcdFx0XHJcblx0XHRcdHJldHVybiByeCA+PSB4ICYmIHJ4IDwgZHggJiYgcnkgPj0geSAmJiByeSA8IGR5O1xyXG5cdFx0fSAvL2lzSW5cclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBJbXByaW50IE1hcCBvbiBSR0xcclxuXHRcdCAqL1xyXG5cdFx0YXN5bmMgc3RhbXAoZHg6IG51bWJlciA9IHRoaXMuZGltZW5zWzBdLCBkeTogbnVtYmVyID0gdGhpcy5kaW1lbnNbMV0sIHg6IG51bWJlciA9IDAsIHk6IG51bWJlciA9IDAsIHN4OiBudW1iZXIgPSB0aGlzLnNjcm9sbFswXSwgc3k6IG51bWJlciA9IHRoaXMuc2Nyb2xsWzFdLCBwYXI6IHJnbC5yZ2wuUkdMID0gdGhpcy5wYXJlbnQpOiBQcm9taXNlPHRoaXM+IHtcclxuXHRcdFx0YXNzZXJ0Lm9rKHBhciwgXCJCYWQgcGFyZW50XCIpO1xyXG5cdFx0XHRcclxuXHRcdFx0Y29uc3Qgc2F2OiBbbnVtYmVyLCBudW1iZXJdID0gWy4uLnBhci5jdXJzb3JdO1xyXG5cdFx0XHRcclxuXHRcdFx0Zm9yIChsZXQgaWR4OiBudW1iZXIgPSAwOyBpZHggPCB0aGlzLmNodW5rcy5sZW5ndGg7IGlkeCsrKSB7XHJcblx0XHRcdFx0Y29uc3QgYzogUkdMTS5SR0xNQ2h1bmsgPSB0aGlzLmNodW5rc1tpZHhdO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmICh0aGlzLmlzSW4oaWR4LCB1bmRlZmluZWQsIHgsIHksIHN4LCBzeSwgZHgsIGR5KSkge1xyXG5cdFx0XHRcdFx0YXdhaXQgcGFyLm1vdmUoLi4uKHRoaXMuY2FsY0Noa0NyZChpZHgpLm1hcCgoYzogbnVtYmVyLCBpZHg6IG51bWJlcik6IG51bWJlciA9PiBjICsgW3N4LCBzeV1baWR4XSkpIGFzIFtudW1iZXIsIG51bWJlcl0pO1xyXG5cdFx0XHRcdFx0cGFyLndyaXRlKGMub25yZW5kZXIoaWR4LCBjLCB0aGlzKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRhd2FpdCBwYXIubW92ZSguLi5zYXYpO1xyXG5cdFx0XHRcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9IC8vc3RhbXBcclxuXHRcdFxyXG5cdFx0KltTeW1ib2wuaXRlcmF0b3JdKCk6IEdlbmVyYXRvcjxSR0xNQ2h1bmssIHZvaWQsIFJHTE1DaHVuaz4ge1xyXG5cdFx0XHRmb3IgKGNvbnN0IGMgb2YgdGhpcy5jaHVua3MpXHJcblx0XHRcdFx0eWllbGQgYztcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Z2V0IFtTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlXSgpOiBib29sZWFuIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcclxuXHRcdH1cclxuXHRcdHRvU3RyaW5nKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmludDtcclxuXHRcdH0gLy90b1N0cmluZ1xyXG5cdFx0XHJcblx0fSAvL1JHTE1hcFxyXG5cdFxyXG59IC8vUkdMTVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUkdMTTtcclxuIl19